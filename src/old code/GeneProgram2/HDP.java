package edu.mit.csail.psrg.georg.GeneProgram2;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import cern.jet.random.Beta;
import cern.jet.random.Gamma;
import cern.jet.random.Uniform;
import edu.mit.csail.psrg.georg.HierarchicalCluster.*;
import edu.mit.csail.psrg.georg.StatUtil.StatUtil;

import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Serializable;
import java.io.ObjectOutputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.FileInputStream;
import java.math.BigInteger;


public class HDP implements Serializable {
	/**
	 * 
	 */
	private static final long serialVersionUID = 9046318985702294357L;
	//	maps original gene numbers to re-ordered genes
	public int[] geneMap;
	// maps re-ordered genes to original gene numbers
	public int[] reverseGeneMap;
	// total unique genes
	public int totalGenes = 0;
	
	// topologically sorted list of DP's
	public DirichletProcess[] DP;
	
	// a DPGroup is a DP node and children,
	// such that the children of the children (document-level DPs)
	// can reassort among the children nodes (and new children nodes can be created)
	public ArrayList<TissueGroup> DPGroups = new ArrayList<TissueGroup>();
	
	// these items refer to the base distribution for topics
	// (a multinomial) with gamma hyper-parameters
	public double priorPos;
	public double priorPos_a = 0.5;
	public double priorPos_b = 0.5;
	public int numExpressionPrograms = 0;
	
	// allocated size of the expression program array
	public int allocExpressionPrograms = 5;
	// amount to expression program allocation by
	public int growExpressionProgramAlloc = 10;
	
	public ArrayList<ExpressionProgram> expressionPrograms = new ArrayList<ExpressionProgram>(); 
	
	// used to store intermediate conditional likelihood computations
	public double[] condLike;
	
	// used to store concentration parameters
	public HDPConcParam[] concParams;
	public UpDownConcParam[] UDconcParams;
	public ModifierConcParam[] ModConcParams;
	
	public String[] geneNames = null;
	
	// variables to control snap-shots (saving of the whole HDP object
	// every N # of samples)
	public int snapShotInterval = 1000;
	public String snapShotFileName = null;
	// variable to control # of iterations after which to start sampling groups
	public int groupStartIter = 0;
	
	// whether to use both up down regulation
	public boolean useUpDown = true;
	// probability of an up expression unit being generated by a topic
	// being used for up-regulated expression
	public double upProb = 0.99;
	// beta parameters (prior counts) for choosing up or down designation for a topic
	public double UD_a = 1.0;
	public double UD_b = 1.0;
	
	// the number of levels for each modifier
	public int[] modifierLevels = null;
	// parameters for Dirichlet prior on modifiers
	public double[][] modifierPrior = null;
	// probability when modifier of gene matches modifier of program
	public double[] matchProbMod = null;
	public double[] unmatchProbMod = null;
	
	public HashMap<Class,HDPStatCollector> statCollectors = new HashMap<Class,HDPStatCollector>();
	
	// the number of expression programs across all samples
	public ArrayList<Integer> numExpressionProgramSamples = new ArrayList<Integer>();
	public boolean collectNumExpressionPrograms = true;
	
	public HDP() {
	}
	
	public void init(int nc,ArrayList<DirichletProcess> dd, HDPConcParam[] cp, UpDownConcParam[] udcp, ModifierConcParam[] mcp, String[] gn, int[] mlvls) {
		priorPos = 0.001;
		numExpressionPrograms = nc;
		concParams = cp;
		UDconcParams = udcp;
		ModConcParams = mcp;
		geneNames = gn;
		modifierLevels = mlvls;
		
		DP = new DirichletProcess[dd.size()];
		int jj = 0;
		for(jj=0;jj<dd.size();jj++) {
			DP[jj] = dd.get(jj);
		}
	}
	
	public void addStatCollector(HDPStatCollector c) {
		statCollectors.put(c.getClass(),c);
	}
	
	public HDPStatCollector getStatCollector(Class c) {
		return statCollectors.get(c);
	}
	
	public void enableSnapShots(int i,String f) {
		snapShotInterval = i;
		snapShotFileName = f;
	}
	
	public void disableSnapShots() {
		snapShotFileName = null;
	}
	
	public void initAllocExpressionPrograms() {
		int totalAllocate = allocExpressionPrograms;
		if (allocExpressionPrograms < numExpressionPrograms+2) {
			totalAllocate = numExpressionPrograms+growExpressionProgramAlloc;
		}
		
		condLike = new double[totalAllocate];
		
		int i = 0;
		for (i=0;i<totalAllocate;i++) {
			expressionPrograms.add(new ExpressionProgram(totalGenes));
		}
		
		allocExpressionPrograms = totalAllocate;
	}
	
	public void addDPGroup(TissueGroup dg) {
		DPGroups.add(dg);
	}
	
	public double[] growDoubleArray(double[] oldArray) {
		if (oldArray.length >= numExpressionPrograms + 5)
			return oldArray;
		
		double[] newArray = new double[numExpressionPrograms + growExpressionProgramAlloc];
		System.arraycopy(oldArray,0,newArray,0,oldArray.length);
		return newArray;
	}
	
	public int[] growIntArray(int[] oldArray) {
		if (oldArray.length >= numExpressionPrograms + 5)
			return oldArray;
		
		int[] newArray = new int[numExpressionPrograms + growExpressionProgramAlloc];
		System.arraycopy(oldArray,0,newArray,0,oldArray.length);
		return newArray;
	}
	
	public boolean[] growBooleanArray(boolean[] oldArray) {
		if (oldArray.length >= numExpressionPrograms + 5)
			return oldArray;
		
		boolean[] newArray = new boolean[numExpressionPrograms + growExpressionProgramAlloc];
		System.arraycopy(oldArray,0,newArray,0,oldArray.length);
		return newArray;
	}
	
	public void addExpressionProgram() {
		int jj = 0;
		
		condLike = growDoubleArray(condLike);
		for (jj=0;jj<DP.length;jj++) {
			DP[jj].growExpressionPrograms();
		}
		
		if (expressionPrograms.size() < numExpressionPrograms+3) {
			for (jj=allocExpressionPrograms;jj<allocExpressionPrograms+growExpressionProgramAlloc;jj++) {
				expressionPrograms.add(new ExpressionProgram(totalGenes));
			}
			allocExpressionPrograms = expressionPrograms.size();
		}
		
		expressionPrograms.get(numExpressionPrograms+1).zeroCounts();
		
		// init appropriate vectors in each DP
		int dd = 0;
		for (jj=0;jj<DP.length;jj++) {
			DP[jj].addExpressionProgram(numExpressionPrograms);
		}
		
		// stick-breaking construction for generating
		// next beta weights
		// sample any other parameters for the new topic
		// as well
		for (jj=0;jj<DP.length;jj++) {
			if (DP[jj].state != DirichletProcess.HELDOUT) {
				DP[jj].sampleNewParameters(numExpressionPrograms);
			}
		}
		
		numExpressionPrograms++;
	}
	
	public void deleteExpressionProgram(int c) {
		// the cluster to be deleted is zero-indexed, as is standard in Java
		
		ExpressionProgram myProgram = expressionPrograms.get(c);
		expressionPrograms.remove(c);
		// put the topic at the end, so that the memory can be used later
		expressionPrograms.add(myProgram);
		
		int jj = 0;
		for(jj=0;jj<DP.length;jj++) {
			if (DP[jj].state != DirichletProcess.HELDOUT) {
				DP[jj].deleteExpressionProgram(c,numExpressionPrograms);
			}
		}
		
		numExpressionPrograms--;
	}
	
	public void resampleConcParams(int numiter) {
  		int cp = 0;
  		for (cp=0;cp<concParams.length;cp++) {
  			concParams[cp].resample(numiter);
  		}
  		
  		if (UDconcParams != null) {
  			for (cp=0;cp<UDconcParams.length;cp++) {
  				UDconcParams[cp].resample(numiter,numExpressionPrograms);
  			}
  		}
  		
  		if (ModConcParams != null) {
  			for (cp=0;cp<ModConcParams.length;cp++) {
  				ModConcParams[cp].resample(numiter,numExpressionPrograms);
  			}
  		}
  	}
  	
	public void resamplePriorPos(int numiter) {
  		int iter, cc, gg, nt;
	  	double aa, bb, xx, nd, zz;
	  	ExpressionProgram myTopic = null;
	  	priorPos = priorPos*((double) totalGenes);
	  	for (iter = 0 ;iter < numiter ;iter++ ) {
	    	aa = priorPos_a;
	    	bb = priorPos_b;
	    	for ( cc = 0 ; cc < numExpressionPrograms; cc++ ) {
	    		myTopic = expressionPrograms.get(cc);
	    		nd = (double) myTopic.totalCount;
	    		if (nd <= 0) {
	      			xx = 1.0;
	      		} else {
	      			xx = Beta.staticNextDouble(priorPos+1.0, nd);
	      		}
	      		if ( Uniform.staticNextDouble() * (priorPos + nd) < nd ) {
	      			zz = 1;
	      		}
	      		else {
	      			zz = 0;
	      		}
	    		nt = 0;
	    		for (gg=0;gg<totalGenes;gg++) {
	    			if (myTopic.posCounts[gg] > 0) {
	    				nt++;
	    			}
	    		}
	      		aa += ((double) nt)-zz;
	      		bb -= Math.log(xx);
	    	}
	    	if (aa >= 1.0) {
	    		priorPos = Gamma.staticNextDouble(aa,1.0) / bb;
	    	}
	  	}
	  	priorPos = priorPos/((double) totalGenes);
  	}
  	
	public void packGenes() {
  		int jj = 0;
  		int kk = 0;
  		int ll = 0;
  		int gene = 0;
  		int i = 0;
  		int j = 0;
  		ArrayList<Integer> genes = new ArrayList<Integer>();
  		int maxGene = 0;
  		TissueDP tissue = null;
  		
  		int tUp = 0;
  		int tDown = 0;
  		int[][] tMod = null;
  		
  		if (modifierLevels != null) {
  			tMod = new int[modifierLevels.length][];
  			modifierPrior = new double[modifierLevels.length][];
  			matchProbMod = new double[modifierLevels.length];
  			unmatchProbMod = new double[modifierLevels.length];
  			for (i=0;i<modifierLevels.length;i++) {
  				tMod[i] = new int[modifierLevels[i]];
  				modifierPrior[i] = new double[modifierLevels[i]];
  				matchProbMod[i] = upProb;
  				unmatchProbMod[i] = (1.0-upProb)/((double) (modifierLevels[i]-1));
  			}
  		}
  		
  		for (jj=0;jj<DP.length;jj++) {
  			if (DP[jj].getClass() == TissueDP.class) {
  				tissue = (TissueDP) DP[jj];
  				for (ll=0;ll<(tissue.genes.length);ll++) {
  					gene = tissue.genes[ll];
  					if (gene > maxGene) {
  						maxGene = gene;
  					}
  					if (useUpDown) {
  						if (tissue.expressionUp[ll]) {
  							tUp++;
  						} else {
  							tDown++;
  						}
  					}
  					if (modifierLevels != null) {
  						for (i=0;i<modifierLevels.length;i++) {
  							tMod[i][tissue.expressionModify[i][ll]]++;
  						}
  					}
  					
  					// the gene was not found
  					if (StatUtil.find(genes,gene) == -1) {
  						genes.add(gene);
  					}
  				}
  			}
  		}
  		
  		totalGenes = genes.size();
  		priorPos = 1.0/((double) totalGenes);
  		priorPos = priorPos*10.0;
  		priorPos_a = 1.0;
  		priorPos_b = 1.0;
  		
  		UD_a = ((double) tUp)/((double) (tUp+tDown));
  		UD_b = 1.0 - UD_a;
  		// necessary for numerical reasons
  		UD_a = UD_a*2.0;
  		UD_b = UD_b*2.0;
  	
  		if (modifierLevels != null) {
  			int modTotal = 0;
  			for (i=0;i<modifierLevels.length;i++) {
  				modTotal = 0;
  				for (j=0;j<tMod[i].length;j++) {
  					modTotal += tMod[i][j];
  				}
  				for (j=0;j<tMod[i].length;j++) {
  					modifierPrior[i][j] = ((double) tMod[i][j])/((double) modTotal);
  				}
  			}
  		}
  		
  		reverseGeneMap = new int[totalGenes];
  		geneMap = new int[maxGene+1];
  		
  		for (jj=0;jj<genes.size();jj++) {
  			geneMap[genes.get(jj)] = jj;
  			reverseGeneMap[jj] = genes.get(jj);
  		}
  		
  		for (jj=0;jj<(DP.length);jj++) {
  			if (DP[jj].getClass() == TissueDP.class) {
  				tissue = (TissueDP) DP[jj];
	  			for (ll=0;ll<(tissue.genes.length);ll++) {
	  				gene = tissue.genes[ll];
	  				tissue.genes[ll] = geneMap[gene];
	  			}
  			}
  		}
  	}
  	
	public void iterate(int numIters,int burnin) {
  		iterate(numIters,burnin,15);
  	}

	public void iterate(int numIters,int burnin,int concParamIter) {
  		int iters = 0;
  		int jj = 0;
  		int cc = 0;
  		int cp = 0;
  		double likelihood = 0.0;
  		double maxLikelihood = -1.0/0.0;
  		int nc = 0;
  		ExpressionProgram myTopic = null;
  		TissueDP tissue = null;
  		
  		String snapShotOutName = "";
  		
  		for (iters=0;iters<numIters;iters++) {
  			for (jj=DP.length-1;jj>=0;jj--) {
  				if (DP[jj].getClass() == TissueDP.class & DP[jj].state == DirichletProcess.ACTIVE) {
  					tissue = (TissueDP) DP[jj];
  					tissue.sampleDataExpressionProgramAssigns();
  				}
  				if (DP[jj].state == DirichletProcess.ACTIVE) {
  					DP[jj].sampleClusterNumTables(numExpressionPrograms);
  				}
  			}
  			
  			for (cp=0;cp<concParams.length;cp++) {
  				concParams[cp].calcTotals(numExpressionPrograms);
  			}
  			
  			for (jj=0;jj<DP.length;jj++) {
  				if (DP[jj].state == DirichletProcess.ACTIVE) {
  					DP[jj].resampleParameters(numExpressionPrograms,condLike);
  				}
  			} 
  			
  			// now delete any empty expression programs
  			nc = numExpressionPrograms;
  			for (cc=nc-1;cc>=0;cc--) {
  				myTopic = expressionPrograms.get(cc);
  				if (myTopic.totalCount == 0) {
  					deleteExpressionProgram(cc);
  				}
  			}
  			
  			int bicluster = 1;
  			if (!DPGroups.isEmpty() & iters > groupStartIter) {
  				for (cc=0;cc<bicluster;cc++) {
	  				for (jj=0;jj<DPGroups.size();jj++) {
	  					DPGroups.get(jj).sampleDPAssignments(numExpressionPrograms);
	  					DPGroups.get(jj).resampleAlpha(concParamIter);
	  					System.out.println("grps=" + DPGroups.get(jj).numClusters + " alpha=" + DPGroups.get(jj).alpha);
	  				}
	  				buildDPList();
	  				
	  				for (jj=DP.length-1;jj>=0;jj--) {
	  					if (DP[jj].state == DirichletProcess.ACTIVE) {
	  						DP[jj].sampleClusterNumTables(numExpressionPrograms);
	  					}
	  	  			}
	  				for (cp=0;cp<concParams.length;cp++) {
	  	  				concParams[cp].calcTotals(numExpressionPrograms);
	  	  			}
	  				for (jj=0;jj<DP.length;jj++) {
	  					if (DP[jj].state == DirichletProcess.ACTIVE) {
	  						DP[jj].resampleParameters(numExpressionPrograms,condLike);
	  					}
		  			}
  				}
  			}
  			
  			resampleConcParams(concParamIter);
  			resamplePriorPos(concParamIter);
  			System.out.println(iters + " " + numExpressionPrograms);
  			
  			if (collectNumExpressionPrograms) {
  				numExpressionProgramSamples.add(numExpressionPrograms);
  			}
  			
  			if (iters >= burnin) {
  				Iterator<HDPStatCollector> statIter = statCollectors.values().iterator();
  				while(statIter.hasNext()) {
  					statIter.next().updateStats();
  				}
  				if (!DPGroups.isEmpty()) {
  					for (jj=0;jj<DPGroups.size();jj++) {
	  					DPGroups.get(jj).incPairProbs();
	  				}
  				}
  			}
  			
  			if (snapShotFileName != null) {
  				double t = ((double) iters+1)/((double) snapShotInterval);
  				if (((double) Math.round(t)) == t) {
  					snapShotOutName = snapShotFileName + "_" + (new Integer(iters)).toString() + ".persist";
  					System.out.println("Snap shot at iteration" + iters);
  					persistSelf(snapShotOutName);
  				}
  			}
  		}
  	}
  	
	public void activateAll() {
  		initAllocExpressionPrograms();
  		int state = 0;
  		
  		int jj = 0;
  		for (jj=0;jj<DP.length;jj++) {
  			if (DP[jj].state == DirichletProcess.ACTIVE) {
  				DP[jj].activate();
  			}
  		}
  		
  		for (jj=0;jj<DP.length;jj++) {
  			if (DP[jj].state == DirichletProcess.ACTIVE) {
  				DP[jj].resampleParameters(numExpressionPrograms,condLike);
  			}
  		}
  		
  		int cp = 0;
  		for (cp=0;cp<concParams.length;cp++) {
  			concParams[cp].calcTotals(numExpressionPrograms);
  		}
  	}
  	
	public void buildDPList(ArrayList<DirichletProcess> activeList,ArrayList<DirichletProcess> totalList) {
  		int i = 0;
  		int j = 0;
  		DirichletProcess dp = null;
  		ArrayList<DirichletProcess> activeList2 = new ArrayList<DirichletProcess>();
  		ParentDP dp2 = null;
  		
  		for (i=0;i<activeList.size();i++) {
  			dp = activeList.get(i);
  			totalList.add(dp);
  			if (dp.getClass() == ParentDP.class) {
  				dp2 = (ParentDP) dp;
  				for(j=0;j<dp2.numChildren();j++) {
  					activeList2.add(dp2.children.get(j));
  				}
  			}
  		}
  		
  		if (!activeList2.isEmpty()) {
			buildDPList(activeList2,totalList);
		}
  	}
  	
	public void buildDPList() {
  		ArrayList<DirichletProcess> activeList = new ArrayList<DirichletProcess>();
  		ArrayList<DirichletProcess> totalList = new ArrayList<DirichletProcess>();
  		activeList.add(DP[0]);
  		buildDPList(activeList,totalList);
  		DirichletProcess[] DP2 = new DirichletProcess[totalList.size()];
  		int i = 0;
  		for (i=0;i<DP2.length;i++) {
  			DP2[i] = totalList.get(i);
  		}
  		DP = DP2;
  	}
  	
	public void persistSelf(String fName) {
  		FileOutputStream fos = null;
  		ObjectOutputStream out = null;
  		try {
  			fos = new FileOutputStream(fName);
  			out = new ObjectOutputStream(fos);
  			out.writeObject(this);
  			out.close();
  			}
  		catch(IOException e) {
  			System.out.println(e);
  		}
  	}
  	
  	public static HDP restoreFromFile(String fName) {
  		HDP myHDP = null;
  		FileInputStream fis = null;
  		ObjectInputStream in = null;
  		try {
  			fis = new FileInputStream(fName);
  		    in = new ObjectInputStream(fis);
  		    myHDP = (HDP) in.readObject();
  		    in.close();
  		} catch(IOException e) {
  			System.out.println(e);
  		} catch(ClassNotFoundException e) {
  			System.out.println(e);
  		}
  		return myHDP;
  	}
  	
  	public void outputNumExpressionProgramSamples(String fName) throws IOException {
  		FileWriter outFile = new FileWriter(fName);
  		int i = 0;
  		for (i=0;i<numExpressionProgramSamples.size();i++) {
  			outFile.write(numExpressionProgramSamples.get(i).toString());
  			outFile.write("\n");
  		}
  		outFile.close();
  	}
}
